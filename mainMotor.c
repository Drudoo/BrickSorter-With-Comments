//
//  main.c
//  ColorSorter
//
//  PIC-2
//
//  Created by Frederik Vanggaard on 4/2/11.
//  Copyright 2011 Drudoo Entertainment. All rights reserved.
//



#pragma config =0x3fdf //MCLRE =off
#pragma config &=0x3ff7 //wdt =off
#pragma config &=0x3ffc //intrc-osc-clkout off

#include "int16CXX.h"


//Variabler 
//Vi definere de variabler som vi skal bruge i vores program.
bit t0, t1, t2, t3, t4, t5; //Vi bruger nogle bit variabler til at check hvorlangt i vores program vi er. I vores main loop kan hver funktion ikke køre før den forrige funktion er færdig.


//Funktioner 
//For at programmet kan køre skal vi have nogle funktioner som burges til at afvikle programmet.

void convertValAD();
void sendBrickToSensor();
void getSensorInput();
void whereToPutBrick();
void deliverBrick();
void resetDirections();
void timerDelay(uns16);
void askForData();


uns16 valAD;
uns8 data, color, gldata;


void main() {       //Her bliver selve programmet afviklet. 


    //Vi starter med at nulstille alle vores porte.

	TRISA=0;    //Vi angiver først vores udgangsporte.
	TRISB=0;
	TRISC=0;
    
	PORTA=0;    //Derefter angiver vi vore indgangsporte.
	PORTB=0;
	PORTC=0;

    //I vores robot bruger vi 2 PICKit 16F690. For at de kan snakke sammen skal vi have en serial kommunikation mellem dem. 
    //Vi bruger en to-vejs kommunikation og derfor skal vi sætte porgrammet op med både modtager og sender. 
    //Meget af det som modtageren skal have sat op bruger senderen også. Vi kan derfor nøjes med at skrive det meste en gang.
    
    //Først initialisere vi BRGH og BRG16 så vi kan få den baud rate vi har brug for fra SPBRG.
    BRGH=1;
	BRG16=1;
    
    //De to PICKit skal bruge den samme baud rate og vi vælger 9600. For at bruge det skal vi sætte SPBRG til 103.
    SPBRG=103;
    
    //Derefter enabler vi serial porten SPEN.
    SPEN=1;
    
    //Da vi ikke bruger 9bit, men i stedet 8bit så enabler vi ikke RX, TX og TX9D. 
	RX9=0;      
    TX9=0;
    TX9D=0;

    //Vi enabler nu CREN så vi kan modtage et signal.
    CREN=1;
    
    //For at få en asynkron drift skal SYNC være clear. 
    SYNC=0;

    //For at enable senderen skal vi sætte TXEN op. Når TXEN bliver sat, så blver TXIF også sat automatisk. Vi vil senere bruge TXIF.
    TXEN=1;
    
    //TRMT indikere om der senderen er idle eller aktiv.
	TRMT=0;
    
    //Vores test bits bliver alle sammen sat til 0 for at programmet kan starte.
	t0 = 0;
	t1 = 0;
	t2 = 0;
	t3 = 0;
	t4 = 0;
	t5 = 0;

	
    
    //Vi er nu færdige med vores opsætning og kan gå igang med vores funktioner.
    
    //Vores første funktion ligger uden for vores while(1) lykke. Det gør at den kun bliver kaldt første gang programmet kører. 
    //Vores robotarm kan være i hvilken som helst possition når den er slukket og når programmet startes så skal den køre til startpossitionen. Det sker når vi kalder resetDirections.
	resetDirections();

    
    //Vi starter nu vores while loop og den indeholder resten af vores program.
	while (1) {	



        //For at programmet kan begynde skal t0-t5 være 0. Det gør vi for at sikre at alle vores main() er blevet udført korrekt. 
        //Hvis ikke at t0-5 er 0 så kan vores funktion ikke starte og resten af programmet kan derfor heller ikke køre. 
		if(!t0&&!t1&&!t2&&!t3&&!t4&&!t5) {
            
            //Vi kalder nu vores første funktion inde i while(1) loop'et. Det er en funktion som skal sende vores klods fra slisken til vores sensor og robotarm. 
            sendBrickToSensor(); 		
            
            //Når den funktion er udført så sætter vi t0 til at være 1. 
            t0 = 1;
		}
		
		//For at give robotten lidt tid, så det hele ikke sker alt for hurtigt så har vi et delay på 1000 milisekunder eller 1 sekund. 
        timerDelay(1000);
			
        
        //For at køre den næste funktion skal t0 er lig med 1. Hvis den forrige funktion ikke er blevet kørt korrekt så vil t0 være lig med 0 og derfor kan denne funktion ikke køre. 
		if(t0) {
            
            
            /*
            Vi havde mange problemer med at få den rigtige farve. 
            Vores problem var at PIC'en med styrede sensoren, PIC-1, hele tiden sendte farve signaler til vores anden PIC, som styrede motoren, PIC-2. 
            Det var derfor ikke altid den rigtige farve som PIC-2 modtog fra PIC-1. 
             
            Problemet kan illustreres ved at sige at en mand står og banker på døren hele tiden. En gang i mellem åbner vi døren og høre på hvad han har at sige. 
            Nogle gang er det bare ikke det helt ny information han fortæller os. 
            Vi rettede op på problemet ved at manden ikke banker på døren hele tiden for at give os information, 
            men bare står og venter på at vi åbner døre og spørg efter den nyeste information.
            */
            
            
            //Vi beder nu vores anden PIC om at få et farve input fra sensoren.
            askForData();
            
            //Når vi har bedt om et farve input, så sætter vi t0 til 0 og t1 til 1. Nu ved vores program at askForData er blevet udført korrekt og at vi kan gå vidre til næste funktion. 
            t0 = 0;
            t1 = 1;
		}

        //Som før så bliver der checket om alle tidligere funktioner er udført korrekt før denne funktionen begynder.
		if(t1) {
            
            //I forrige funktion bedte vi PIC-1 og en farve input og det er her at PIC-2 nu modtager dette input. 
            getSensorInput();
            
            t1 = 0;
            t2 = 1;
		}


 		if(t2) {
            
            //Når vi har fået et input fra sensoren så skal vi finde ud af hvilken farve det er en hvor den skal lægges.
            //Denne funktion bestemmer på baggrund af getSensorInput, hvor langt vores robotarm skal dreje før den smider klodsen af.
            whereToPutBrick();
            
            t2 = 0;
            t3 = 1;
		}
		
		if(t3) {
            
            //Når vores robotarm har drejet der hend hvor den skal være så skal klodsen skubbes ud af armen og ned i en beholder. 
            //Denne funktion sørger for dette og som i de andre funktioner så kan den ikke køres før de andre er færdige. 
            deliverBrick();
            t3 = 0;
            t4 = 1;
		}
		
		if(t4) {
            
            //Når vi har leveret vores klods, så er det på tide at vende tilbage til start possitionen og begynde forfra.
            //Her bruger vi den samme funktion som vi havde i starten.
            resetDirections();
            t4 = 0;
		}
		
        //Vi er nu færdige med vores while(1) loop og alle vores t0-t5 værdier er igen 0. Det loop'et kan nu køres igen uden af få nogle errors på grund af tidligere gennemkørsler. 
		
    }
}


/*
    Indtil vidre har vi ikke skrevet hvad vores funktioner skal gøre. Dette er det gode ved test-driven development. 
    Alle burde kunne forstå hvad der er skrevet i vores while loop og ved hvad programmet skal gøre. 
    Vi skal nu til at skrive alle vores funktioner og hvad de gør. 
 
    Funktionerne her bliver ikke kaldt i den rækkefølge de er i her. De bliver kaldt som de står i void main funktionen. 
    Det er derfor lige meget hvilken rækkefølge de står i her, men for at gøre det lettere for os selv og fordi vi bruger test-driven development så står de næsten altid i rigtig rækkefølge.

    Vores første funktion skal resette vores robotarm. Det gør den ved først at checke om vores kontakt er trykket ind eller ej. 
    Kontakten virker på den måde at hvis den er trykket ind så løber der ikke nogen spænding i gennem den. Hvis den ikke er trykket ind så løber der 5 volt i gennem den.
    I denne funktion så checker vi om den er ikke er trykket ind. 
 */
void resetDirections () {

        //Hvis kontakten ikke er trykket ind så skal vores motor køre i en uendelighed. 
        //Når kontakten så bliver trykket ind, så til while loop'et stoppe og programmet vil gå videre til næste del af funktionen. 
	while(PORTA.4) {    //Vores PORTA.4 er ben 3 på PIC'en. 

		PORTC.0 = 1;   
        PORTC.6 = 0;    

/*
    PORTC.0 og PORTC.6 er hendholdsvis ben 16 og 8 på PIC'en. De går fra PIC'en hend til vores H-bro som står for motorstyringen og derefter videre til selve motoren. 
    Når PORTC.6 er 0 betyder det at der ikke løber en spænding hend til H-broen. Når PORTC.0 tilgængæld er 1 så løber der en spænding på 5 volt til H-broen,
    som så sender 9volt hend til motoren.
*/
        
    }
        
    //Når kontakten så bliver trykket ind stopper vores motor med at køre og funktionen er færdig. 
	PORTC.0 = 0;
	PORTC.6 = 0;


}


/*
    Det næste vi skal have gjort er at sende vores klods til sensoren. Det er egentlig gjort på samme måde som i forrige funktion. 
    Vi starter med at åbne for PORTC.1 (ben 15) og holder PORTC.2 (ben 14) lukket.
    Derefter venter vi i 450 millisekunder eller 0.45 sekunder og så gør vi det omvendte for at få vores motor til at køre den anden vej. 
    Vi har igen et delay, og til slut lukker vi for begge porte så motoren ikke køre nogen steder. 
    For at køre hele processen lidt langsommere tilføjer vi en pause på 1000 millisekunder (1 sekund)
*/

void sendBrickToSensor()  {
    

		PORTC.1 = 1;
		PORTC.2 = 0;

		timerDelay(450);

		PORTC.1 = 0;
		PORTC.2 = 1;

		timerDelay(450);

		PORTC.1 = 0;
		PORTC.2 = 0;

		timerDelay(1000);

}


/*
    Vi skal nu til at sende og modtage signaler. Den serielle kommunikation mellem PIC-1 og PIC-2 har været vores største problem i programmeringen. 
    Vi starter med at have en 8bit variable som hedder modtagData. Den modtager data fra PIC-1 og gemmer det, så vi kan kalde 'modtagData();' senere og bruge det i vores funktion. 
*/

uns8 modtagData() {
	uns8 data;
	data = 0;

/*    
    I starten af vores 'void main' satte vi CREN = 1. Det gjorde vi fordi hvis den er 0, så kan vores PIC ikke modtage et signal. 
    Vi fik ret store problemer fordi efter 2 omgange af vores while(1) loop så stoppede vi med at få et signal fra PIC-1.
    Vi fandt efter lang tid ud af at der i datasheetet for PIC'en står: (side 159, afsnit 12.1.2.5)
 
 
        *********************************************************************
        *                                                                   *
        *                Receive Overrun Error                              *
        *    The receive FIFO buffer can hold two characters. An            *
        *    overrun error will be generated If a third character, in its   *
        *    entirety, is received before the FIFO is accessed. When        *
        *    this happens the OERR bit of the RCSTA register is set.        *
        *    The characters already in the FIFO buffer can be read          *
        *    but no additional characters will be received until the        *
        *    error is cleared. The error must be cleared by either          *
        *    clearing the CREN bit of the RCSTA register or by              *
        *    resetting the EUSART by clearing the SPEN bit of the           *
        *    RCSTA register.                                                *
        *                                                                   *
        *********************************************************************
 
 Det betød at fordi vores CREN altid var 1, og derfor aldrig blev cleared, så blev der lavet en overrun error når den fix mere end 3 tal. 
 Det vi derfor gjorde var at sætte CREN = 0 for at sikre os at den var cleared og derefter sætte CREN = 1 igen, så vi igen kan modtage et signal.
 Vi modtager data på ben 12 (RB5/RX) og sender på ben 10 (RB7/TX)
 */
 
    CREN = 0;
	CREN = 1;

	while(!RCIF) {
    }
	
    data = RCREG;
	RCIF = 0;
    return data;
}

void sendData(uns8 ud) {
    
	while(!TXIF) {
    }
	
    TXREG=ud;
	TXIF=0;
}

//Vi har nu vores funktion, hvor vi spørger PIC-1 og et input fra sensoren. Vi sender derfor et signal fra PIC-2 til PIC-1. Signalet er meget simpelt og indeholder kun et ettal (1).
void askForData() {
	sendData(1);
	
}


//Når PIC-1 har modtaget vores signal så sender den en farve tilbage. Det gør den i form at tal fra 1-6. 
//Vi modtager tallet som modtagData();, men for at gøre det lettere for os selv og programmeringen så skriver vi at color skal være lig med modtagData();. 
//Det gør at vi fremover bare kan kalde color og så får vi vores modtagData();
void getSensorInput() {
  
	color = modtagData();	
    
}


/*
    Når vi har fået farven så skal vi finde ou af hvor vi skal ligge vores klods. Det gør vi ved at sige at hvis color er lig med 1, 
    så skal vi dreje robotarmen i 500 millisekunder (0.5 sekunder) og derefter stoppe. 
    I tidligere funktioner har vi bagefter at have kørt motoren den ene vej, så kørt den anden vej. 
    Det skal vi ikke her fordi vi i mellemtiden skal stubbe klodsen ud af vores arm med en anden funktion.
*/

void whereToPutBrick() {
  

	if (color == 1) {

		PORTC.0 = 0;
		PORTC.6 = 1;

		timerDelay(500);

		PORTC.6 = 0;
	} 



	if (color == 2) {


		PORTC.0 = 0;
		PORTC.6 = 1;

		timerDelay(1000);

		PORTC.6 = 0;


	}
	


	if (color == 3) {
		PORTC.0 = 0;
		PORTC.6 = 1;

		timerDelay(1500);

		PORTC.6 = 0;
	}	



	if (color == 4) {

		PORTC.0 = 0;
		PORTC.6 = 1;

		timerDelay(2300);

		PORTC.6 = 0;
	}
	


	if (color == 5) {
		PORTC.0 = 0;
		PORTC.6 = 1;

		timerDelay(2800);

		PORTC.6 = 0;
	}
	

	if (color == 6) {

		PORTC.0 = 0;
		PORTC.6 = 1;

		timerDelay(2700);

		PORTC.6 = 0;

	}

	


}

//Her skubber vi klodsen ud af vores robotarm og denne funktion gør det samme som sendBrickToSensor.
//De ben vi bruger her er PORTC.3 (ben 7) og PORTC.4 (ben 6)

void deliverBrick() {

		PORTC.3 = 0;	
		PORTC.4 = 1;	

		timerDelay(150);

		PORTC.3 = 1;
		PORTC.4 = 0;
		
		timerDelay(150);
		
		PORTC.3 = 0;

		timerDelay(1000);
}


//Den sidste funktion er vores timer. PIC'en har en indbygger timer funktion og det er den vi har brugt til alle vores delays. 

//Giver n millesekund delay
void timerDelay(uns16 n) {
    
    INTCON.2=0;
	OPTION_REG=2;
	TMR0 = -125	;
	
    do {
		
        do {
        }
        
		while(!INTCON.2);
		TMR0=-125;
		INTCON.2=0;
	}
	
    while(--n>0);

}